// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                    @id @default(uuid())
  name              String?
  email             String                    @unique
  emailVerified     DateTime?                 @map("email_verified")
  password          String?                   // For NextAuth - stores hashed password (nullable temporarily for migration)
  passwordHash      String?                   @map("password_hash") // Keep for backward compatibility (optional)
  role              String                    @default("user") @db.VarChar(50)
  image             String?
  active            Boolean                   @default(true)
  createdAt         DateTime                  @default(now()) @map("created_at")
  updatedAt         DateTime                  @updatedAt @map("updated_at")
  accounts          Account[]
  sessions          Session[]
  paypalAccounts    PayPalAccount[]
  accountPermissions UserAccountPermission[]
  preferences       UserPreference?

  @@map("users")
}

model PayPalAccount {
  id                  String                  @id @default(uuid())
  userId              String?                 @map("user_id")
  accountName         String                  @map("account_name") @db.VarChar(255)
  email               String                  @db.VarChar(255)
  clientId            String                  @map("client_id") // Will be encrypted
  secretKey           String                  @map("secret_key") // Will be encrypted
  sandboxMode         Boolean                 @default(false) @map("sandbox_mode")
  active              Boolean                 @default(true)
  lastSyncAt          DateTime?               @map("last_sync_at")
  createdAt           DateTime                @default(now()) @map("created_at")
  updatedAt           DateTime                @updatedAt @map("updated_at")
  user                User?                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  disputes            Dispute[]
  syncLogs            SyncLog[]
  accountPermissions  UserAccountPermission[]

  @@index([userId])
  @@map("paypal_accounts")
}

model Dispute {
  id                String            @id @default(uuid())
  paypalAccountId   String            @map("paypal_account_id")
  disputeId         String            @unique @map("dispute_id") @db.VarChar(255)
  transactionId     String?           @map("transaction_id") @db.VarChar(255)
  invoiceNumber     String?           @map("invoice_number") @db.VarChar(255)
  disputeAmount     Decimal?          @map("dispute_amount") @db.Decimal(10, 2)
  disputeCurrency   String?           @map("dispute_currency") @db.VarChar(3)
  customerEmail     String?           @map("customer_email") @db.VarChar(255)
  customerName      String?           @map("customer_name") @db.VarChar(255)
  disputeType       String?           @map("dispute_type") @db.VarChar(50)
  disputeReason     String?           @map("dispute_reason") @db.VarChar(100)
  disputeStatus     String?           @map("dispute_status") @db.VarChar(50)
  disputeOutcome    String?           @map("dispute_outcome") @db.VarChar(50)
  description       String?           @db.Text
  disputeChannel    String?           @map("dispute_channel") @db.VarChar(50)
  disputeCreateTime DateTime?         @map("dispute_create_time")
  disputeUpdateTime DateTime?         @map("dispute_update_time")
  responseDueDate   DateTime?         @map("response_due_date")
  resolvedAt        DateTime?         @map("resolved_at")
  rawData           Json?             @map("raw_data")
  createdAt         DateTime          @default(now()) @map("created_at")
  updatedAt         DateTime          @updatedAt @map("updated_at")
  paypalAccount     PayPalAccount     @relation(fields: [paypalAccountId], references: [id], onDelete: Cascade)
  history           DisputeHistory[]
  messages          DisputeMessage[]

  @@index([paypalAccountId])
  @@index([disputeId])
  @@index([disputeStatus])
  @@index([disputeCreateTime])
  @@map("disputes")
}

model DisputeHistory {
  id          String   @id @default(uuid())
  disputeId   String   @map("dispute_id")
  actionType  String   @map("action_type") @db.VarChar(50)
  actionBy    String?  @map("action_by") @db.VarChar(50)
  oldValue    String?  @map("old_value") @db.Text
  newValue    String?  @map("new_value") @db.Text
  description String?  @db.Text
  metadata    Json?
  createdAt   DateTime @default(now()) @map("created_at")
  dispute     Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  @@index([disputeId])
  @@index([createdAt])
  @@map("dispute_history")
}

model DisputeMessage {
  id          String   @id @default(uuid())
  disputeId   String   @map("dispute_id")
  messageType String   @map("message_type") @db.VarChar(50)
  postedBy    String?  @map("posted_by") @db.VarChar(50)
  content     String?  @db.Text
  attachments Json?
  createdAt   DateTime @default(now()) @map("created_at")
  dispute     Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  @@index([disputeId])
  @@index([createdAt])
  @@map("dispute_messages")
}

model SyncLog {
  id              String        @id @default(uuid())
  paypalAccountId String        @map("paypal_account_id")
  syncType        String        @map("sync_type") @db.VarChar(50)
  status          String        @db.VarChar(20)
  disputesSynced  Int?          @map("disputes_synced")
  errors          String?       @db.Text
  startedAt       DateTime?     @map("started_at")
  completedAt     DateTime?     @map("completed_at")
  createdAt       DateTime      @default(now()) @map("created_at")
  paypalAccount   PayPalAccount @relation(fields: [paypalAccountId], references: [id], onDelete: Cascade)

  @@index([paypalAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("sync_logs")
}

// NextAuth models
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text @map("refresh_token")
  access_token      String? @db.Text @map("access_token")
  expires_at        Int?    @map("expires_at")
  token_type        String? @map("token_type")
  scope             String?
  id_token          String? @db.Text @map("id_token")
  session_state     String? @map("session_state")
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model UserAccountPermission {
  id              String        @id @default(uuid())
  userId          String        @map("user_id")
  paypalAccountId String        @map("paypal_account_id")
  permissionLevel String        @default("viewer") @map("permission_level") @db.VarChar(50) // owner, editor, viewer
  createdAt       DateTime      @default(now()) @map("created_at")
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  paypalAccount   PayPalAccount @relation(fields: [paypalAccountId], references: [id], onDelete: Cascade)

  @@unique([userId, paypalAccountId])
  @@index([userId])
  @@index([paypalAccountId])
  @@map("user_account_permissions")
}

// System-wide settings (admin only)
model Setting {
  id          String   @id @default(uuid())
  key         String   @unique @db.VarChar(100)
  value       String?  @db.Text
  description String?  @db.Text
  category    String?  @db.VarChar(50) // general, sync, security, notification, etc.
  updatedAt   DateTime @updatedAt @map("updated_at")
  updatedBy   String?  @map("updated_by") @db.VarChar(255)

  @@index([category])
  @@map("settings")
}

// User-specific preferences
model UserPreference {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id")
  preferences Json   // Store all user preferences as JSON
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_preferences")
}
